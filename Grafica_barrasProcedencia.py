{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "f3ef600f-3bf3-4279-898f-bb74bb9e7211",
   "metadata": {},
   "outputs": [],
   "source": [
    "import polars as pl\n",
    "import plotly.express as px"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "fc1f45e9-9c22-464b-a4aa-e89038a507e2",
   "metadata": {},
   "outputs": [],
   "source": [
    "SNIB_DATA_PARQUET = \"./data/SNIBEjemplares_20250803_233426.parquet\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "1a3f31ce-6a32-4b31-8a47-d4f9898b7e09",
   "metadata": {},
   "outputs": [],
   "source": [
    "snib_lazy_df = pl.scan_parquet(SNIB_DATA_PARQUET)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "a1912a78-0b00-4cdd-ad02-66336feb3254",
   "metadata": {},
   "outputs": [],
   "source": [
    "ejemplares_anio_reino1 = (\n",
    "    snib_lazy_df.select(pl.col([\"grupobio\", \"procedenciaejemplar\", \"aniocolecta\" ]))\n",
    "        .filter(\n",
    "            (pl.col(\"grupobio\").is_not_null()) & \n",
    "            (pl.col(\"procedenciaejemplar\").is_not_null()) & \n",
    "            (pl.col(\"grupobio\").str.strip_chars() != \"\") & \n",
    "            (pl.col(\"procedenciaejemplar\").str.strip_chars() != \"\")\n",
    "        )\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "43922e00-5971-48c2-9d8d-c3ef106ad8cb",
   "metadata": {},
   "outputs": [],
   "source": [
    "conteo_por_reinoprocanio_lazy = (\n",
    "    ejemplares_anio_reino1\n",
    "    .group_by(\"grupobio\", \"procedenciaejemplar\")  # Agrupa por la columna categórica\n",
    "    .agg(\n",
    "        pl.len().alias(\"conteo\")  # Cuenta el número de filas en cada grupo y renómbralo a \"conteo\"\n",
    "    )\n",
    "    .sort(\"conteo\", descending=True) # Opcional: ordena para que el gráfico se vea mejor\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42376369-16d8-46eb-9181-14598b7eee03",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "df_resultado_polars1 = conteo_por_reinoprocanio_lazy.collect()\n",
    "\n",
    "# Imprimimos el DataFrame resultante para ver qué contiene\n",
    "print(\"DataFrame que se usará para el gráfico:\")\n",
    "print(df_resultado_polars1)\n",
    "\n",
    "# 3. GRÁFICO DE BURBUJAS: Usamos px.scatter\n",
    "# Un gráfico de burbujas es un gráfico de dispersión donde el tamaño de los puntos varía.\n",
    "fig = px.scatter(\n",
    "    df_resultado_polars1,\n",
    "    x=\"grupobio\",          # Eje X: El país de colección\n",
    "    y=\"procedenciaejemplar\",                  # Eje Y: El reino\n",
    "    size=\"conteo\",              # Tamaño de la burbuja: El número de ejemplares\n",
    "    color=\"procedenciaejemplar\",              # Color de la burbuja: Distingue los reinos\n",
    "    hover_name=\"procedenciaejemplar\", # Texto que aparece en negritas al pasar el ratón\n",
    "    size_max=60,                # Aumenta el tamaño máximo de la burbuja más grande para mejor visibilidad\n",
    "    title=\"Cantidad de Ejemplares por porcedncia de grupobiologico\"\n",
    ")\n",
    "\n",
    "# Mejoramos el diseño para que no se vea tan apretado\n",
    "fig.update_layout(\n",
    "    xaxis_title=\"procedencia\",\n",
    "    yaxis_title=\"grupobiologico\",\n",
    "    title_x=0.5 # Centrar el título\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "28a326a3-9243-4e33-b076-8ede627d366a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Diccionario de mapeo\n",
    "mapeo_procedencia = {\n",
    "    \"HumanObservation\": \"Observacion humana\",\n",
    "    \"PreservedSpecimen\": \"Especimen preservado\",\n",
    "    \"MachineObservation\": \"Observacion de maquina\",\n",
    "    \"LivingSpecimen\": \"Especimen vivo\",\n",
    "    \"FossilSpecimen\": \"Especimen fosil\",     \n",
    "    \"Occurrence\": \"Evidencia\",\n",
    "    \"Materialsample\": \"muestra de material\",\n",
    "    \"MaterialCitation\": \"Material citado\"\n",
    "}\n",
    "# Crear DataFrame de mapeo (no lazy)\n",
    "mapeo_df = pl.DataFrame({\n",
    "    \"procedenciaejemplar\": list(mapeo_procedencia.keys()),\n",
    "    \"procedenciaejemplar_es\": list(mapeo_procedencia.values())\n",
    "})\n",
    "# Filtrar datos (no lazy)\n",
    "ejemplares_df = snib_lazy_df.select(pl.col([\"grupobio\", \"procedenciaejemplar\"])).collect()\n",
    "ejemplares_df = ejemplares_df.filter(\n",
    "    (pl.col(\"grupobio\").is_not_null()) & \n",
    "    (pl.col(\"procedenciaejemplar\").is_not_null()) & \n",
    "    (pl.col(\"grupobio\").str.strip_chars() != \"\") & \n",
    "    (pl.col(\"procedenciaejemplar\").str.strip_chars() != \"\")\n",
    ")\n",
    "# Hacer join para mapear al español (no lazy)\n",
    "ejemplares_mapeados = ejemplares_df.join(\n",
    "    mapeo_df,\n",
    "    on=\"procedenciaejemplar\",\n",
    "    how=\"left\"\n",
    ").with_columns(\n",
    "    pl.when(pl.col(\"procedenciaejemplar_es\").is_not_null())\n",
    "      .then(pl.col(\"procedenciaejemplar_es\"))\n",
    "      .otherwise(pl.col(\"procedenciaejemplar\"))\n",
    "      .alias(\"procedenciaejemplar_mapeado\")\n",
    ")\n",
    "# Agrupar y contar\n",
    "conteo_df = ejemplares_mapeados.group_by([\"grupobio\", \"procedenciaejemplar_mapeado\"]).agg(\n",
    "    pl.len().alias(\"conteo\")\n",
    ")\n",
    "# Obtener listas únicas para índices y columnas\n",
    "grupos = conteo_df.select(\"grupobio\").unique().to_series().to_list()\n",
    "procedencias = conteo_df.select(\"procedenciaejemplar_mapeado\").unique().to_series().to_list()\n",
    "# Construir diccionario para acceso rápido\n",
    "data = {}\n",
    "for row in conteo_df.iter_rows():\n",
    "    grupo, procedencia, conteo = row\n",
    "    data.setdefault(grupo, {})[procedencia] = conteo\n",
    "    # Imprimir gráfico de barras en texto\n",
    "max_bar_length = 40  # longitud máxima de barra en caracteres\n",
    "print(\"Cantidad de Ejemplares por Grupo Biológico y Procedencia\\n\")\n",
    "for grupo in grupos:\n",
    "    print(f\"Grupo: {grupo}\")\n",
    "    total = sum(data.get(grupo, {}).values())\n",
    "    for procedencia in procedencias:\n",
    "        count = data.get(grupo, {}).get(procedencia, 0)\n",
    "        if total > 0:\n",
    "            bar_len = int((count / total) * max_bar_length)\n",
    "        else:\n",
    "            bar_len = 0\n",
    "        bar = \"█\" * bar_len\n",
    "        print(f\"  {procedencia[:20]:20} | {bar} {count}\")\n",
    "    print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "58ca8a2b-0b1c-44f1-a55d-d00a17ec7f90",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 1. Calcular el total por grupo\n",
    "totales = (\n",
    "    conteo_df.group_by(\"grupobio\")\n",
    "    .agg(pl.col(\"conteo\").sum().alias(\"total\"))\n",
    "    .sort(\"total\", descending=True)\n",
    ")\n",
    "\n",
    "# 2. Extraer el orden en lista\n",
    "orden_grupos = totales[\"grupobio\"].to_list()\n",
    "\n",
    "# 3. Hacer la gráfica horizontal respetando el orden\n",
    "fig = px.bar(\n",
    "    conteo_df,\n",
    "    y=\"grupobio\",\n",
    "    x=\"conteo\",\n",
    "    color=\"procedenciaejemplar_mapeado\",\n",
    "    barmode=\"stack\",\n",
    "    category_orders={\"grupobio\": orden_grupos},# <- orden personalizado\n",
    "\n",
    "    labels={\n",
    "        \"grupobio\": \"Grupo Biológico\",\n",
    "        \"estatustax\": \"Estatus\",\n",
    "        \"porcentaje_grupo\": \"Porcentaje\"\n",
    "    }\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    title=\"Procedencia de grupos biológicos (ordenados de mayor a menor)\",\n",
    "    xaxis_title=\"Número de ejemplares\",\n",
    "    yaxis_title=\"Grupo biológico\",\n",
    "    legend_title=\"Procedencia\"\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "30a62b70-b0f3-418b-b143-7a5a86ed4493",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
